---
title: "Projeto MEG, Parte II - Questão 1"
author: "Andreia Marçal & Filipe Santos"
date: "13/06/2020"
output: html_document
---

```{r}
rm(list=ls())
```

# Bibliotecas

```{r}
# BiocManager::install("genArise")
# library(locfit)
# library(tkrplot)
# library(xtable)

library(genArise)
library(limma)
library(ggplot2)
```

# Dados

```{r}
chip1 <- read.table("chip1.txt", header = T) 
class(chip1) # "data.frame"

chip1.spot <- read.spot("chip1.txt", cy3 = 3, cy5 = 2, bg.cy3 = 5, bg.cy5 = 4, ids = 1, header = T, sep = "\t", is.ifc = FALSE) #Cy3 - Ven (green); Cy5 - Art (red)
class(chip1.spot) # "Spot"

data(chip1) # data set �chip1.df� not found
data(chip1.spot) # data set �chip1.spot� not found
ls() # "chip1.df" "chip1.spot"
```

# Chip 1

## a) Represente graﬁcamente as intensidades observadas nos dois canais, através do diagrama de dispersão e do MA-plot.

```{r}
# diagrama de dispersão:
#plot(chip1$Art, chip1$Art, xlab = "Art", ylab = "Art")

ggplot(chip1) +
  geom_point(aes(x = Art, y = Art)) +
  geom_abline() +
  xlab("Art") +
  ylab("Art")

ggplot# MA-plot (linear regression of log ratio against average itensity):
ma.plot(chip1.spot)
```


## b) Faça a subtração do background, nos dois canais, e compare os resultados utilizando a representação gráﬁca conArtiente. 

```{r}
par(mfrow=c(1,2))
c.spot <- bg.correct(chip1.spot)

# Raw data
ma.plot(c.spot)
title(main = "Raw")

# Background corrected
ma.plot(c.spot)
title(main="Corrected")
```


## c) Normalize o array e volte a comparar os resultados. 

```{r}
# grid normalization 
grid.n.spot <- grid.norm(c.spot, nr=2994, nc=5) # ??nr ??nc
#ri.plot(n.spot)
#ma.plot(n.spot)

# global normalization
global.n.spot <- global.norm(c.spot)
# ri.plot(n.spot)
# ma.plot(n.spot)

# comparing Raw vs Corrected vs Normalized & Corrected
par(mfrow=c(1,3))
ma.plot(chip1.spot)
ma.plot(c.spot)
ma.plot(n.spot)
par(mfrow=c(1,1))
```


## d) Calcule o Z-score para cada gene. Construa o gráﬁco adequado e baseie-se nele para estabelecer um ponto de corte que lhe permita criar listas de genes com expressão diferencial em Art e em Art.

```{r}
# Identifying differentially expressed genes
# Z-score, M-A plot
zScore1 <- Zscore(global.n.spot, type = "ma")

# plotting datasets - s.spot
Zscore.plot(zScore1)
abline(h=2, col='white', lty=2) 
abline(h=-2, col='white', lty=2)
```

# Chips 2 e 3
```{r}
# importing chips 2 and 3
chip2 <- read.table("chip2.txt", header = T)
chip3 <- read.table("chip3.txt", header = T)

# getting spot objects from chip data
spot2 <- read.spot("chip2.txt", header=T, cy3=2, bg.cy3=4, cy5=3, bg.cy5=5, ids=1, sep = "\t", is.ifc = FALSE)
#str(spot2)
spot3 <- read.spot("chip3.txt", header=T, cy3=2, bg.cy3=4, cy5=3, bg.cy5=5, ids=1, sep = "\t", is.ifc = FALSE)
#str(spot3)

# Background correction
spot2 <- bg.correct(spot2)
spot3 <- bg.correct(spot3)
```

## e) Normalize os dois arrays tendo em conta o processo de normalização considerado anteriormente.
```{r}
# grid normalization
grNorm2 <- grid.norm(mySpot = spot2, nr=2994, nc=5)
#ma.plot(grNorm2)

grNorm3 <- grid.norm(mySpot = spot3, nr=2994, nc=5)
#ma.plot(grNorm3)

# global normalization
glNorm2 <- global.norm(mySpot = spot2)
ma.plot(glNorm2)

glNorm3 <- global.norm(mySpot = spot3)
ma.plot(glNorm3)
```

## f) Proceda à normalização entre arrays fazendo uma transformação conveniente dos dados (sugestão: centering).
```{r}
# Chip1
chip1data <- attr(n.spot, "spotData")
M1 <- log(chip1data$Cy3, 2) - log(chip1data$Cy5, 2)
med1 <- median(M1)
mad1 <- mad(M1)
normChip1 <- (M1 - med1) / mad1

# Chip2
chip2data <- attr(glNorm2, "spotData")
M2 <- log(chip2data$Cy3, 2) - log(chip2data$Cy5, 2)
med2 <- median(M2)
mad2 <- mad(M2)
normChip2 <- (M2 - med2) / mad2

# Chip3
chip3data <- attr(glNorm3, "spotData")
M3 <- log(chip3data$Cy3, 2) - log(chip3data$Cy5, 2)
med3 <- median(M3)
mad3 <- mad(M3)
normChip3 <- (M3 - med3) / mad3

normTable <- data.frame(normChip1, normChip2, normChip3)
boxplot(normTable, ylab="(Xi-median(X))/mad(X)")
```

## g) Com base nos Z-scores identifique os genes com expressão diferencial nos três arrays. Comente este procedimento.
```{r}
zScore2 <- Zscore(glNorm2, type="ma")
zScore3 <- Zscore(glNorm3, type="ma")

Zscore.plot(zScore1)
abline(h=2, col='white', lty=2) 
abline(h=-2, col='white', lty=2) 

Zscore.plot(zScore2)
abline(h=2, col='white', lty=2) 
abline(h=-2, col='white', lty=2) 

Zscore.plot(zScore3)
abline(h=2, col='white', lty=2) 
abline(h=-2, col='white', lty=2)
```

+ Identificação dos genes com expressão diferencial em cada um dos 3 arrays.

```{r}
ds1 <- attr(zScore1, "dataSets")
diff1 <- ds1$Id[abs(ds1$Zscore) > 2]
#diff1

ds2 <- attr(zScore2, "dataSets")
diff2 <- ds2$Id[abs(ds2$Zscore) > 2]
#diff2

ds3 <- attr(zScore3, "dataSets")
diff3 <- ds3$Id[abs(ds3$Zscore) > 2]
#diff3

difExp1 <- length(diff1) # should be about 30 genes
difExp2 <- length(diff2)
difExp3 <- length(diff3)

difExp1 / 2994 # should be ~0.01 (?)
difExp2 / 2994
difExp3 / 2994
length(diff1) + length(diff2) + length(diff3)
```

## h) Aplique o método bayesiano de Lonnstedt e Speed (package limma). Estabeleça algumas linhas de comando para identificar os genes com expressão diferencial e justifique o ponto de corte considerado.

Ponto de corte - Bi>0; explicação no vídeo da aula de 21/5 (1:55:00)
Selecionam-se genes com maior valor de B
```{r}

# Chip1
bayes1 <- attr(global.n.spot, "spotData")
ratio11 <- log(bayes1$Cy3, 2) - log(bayes1$Cy5, 2) #Cy3/Cy5 - coeficiente = -1
ratio12 <- log(bayes1$Cy5, 2) - log(bayes1$Cy3, 2) #Cy5/Cy3 - coeficiente = 1

# Chip2
bayes2 <- attr(glNorm2, "spotData")
ratio21 <- log(bayes2$Cy3, 2) - log(bayes2$Cy5, 2) #Cy3/Cy5 - coeficiente = -1
ratio22 <- log(bayes2$Cy5, 2) - log(bayes2$Cy3, 2) #Cy5/Cy3 - coeficiente = 1

# Chip3
bayes3 <- attr(glNorm3, "spotData")
ratio31 <- log(bayes3$Cy3, 2) - log(bayes3$Cy5, 2) #Cy3/Cy5 - coeficiente = -1
ratio32 <- log(bayes3$Cy5, 2) - log(bayes3$Cy3, 2) #Cy5/Cy3 - coeficiente = 1

ratios <- data.frame(ratio11, ratio12, ratio21, ratio22, ratio31, ratio32)
design <- c(-1, 1, -1, 1, -1, 1)
fit <- lmFit(ratios, design)
fit <- eBayes(fit)

table <- topTable(fit, number=nrow(fit), adjust="BH", sort.by = "B")
table <- subset(table, table$B > 0); table

volcanoplot(fit, highlight = 20)
abline(3.5,0)
abline(v=-1)
abline(v=1)
```

## i) Comente os resultados obtidos pelos dois métodos.





