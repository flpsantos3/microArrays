---
title: "Projeto MEG, Parte II - Questão 1"
author: "Andreia Marçal & Filipe Santos"
date: "13/06/2020"
output: html_document
---

```{r}
rm(list=ls())
```

# Bibliotecas

```{r}
# BiocManager::install("genArise")
# library(locfit)
# library(tkrplot)
# library(xtable)

library(genArise)
library(limma)
library(ggplot2)
library(stringr)
library(gtools)
```

# Dados

```{r}
chip1 <- read.table("chip1.txt", header = T) 
class(chip1) # "data.frame"

chip1.spot <- read.spot("chip1.txt", cy3 = 3, cy5 = 2, bg.cy3 = 5, bg.cy5 = 4, ids = 1, header = T, sep = "\t", is.ifc = FALSE) #Cy3 - Ven (green); Cy5 - Art (red)
class(chip1.spot) # "Spot"

data(chip1) # data set �chip1.df� not found
data(chip1.spot) # data set �chip1.spot� not found
ls() # "chip1.df" "chip1.spot"
```

# Chip 1

## a) Represente graﬁcamente as intensidades observadas nos dois canais, através do diagrama de dispersão e do MA-plot.

```{r}
# diagrama de dispersão:
#plot(chip1$Art, chip1$Art, xlab = "Art", ylab = "Art")

ggplot(chip1) +
  geom_point(aes(x = Art, y = Art)) +
  geom_abline() +
  xlab("Art") +
  ylab("Art")

ggplot# MA-plot (linear regression of log ratio against average itensity):
ma.plot(chip1.spot)
```


## b) Faça a subtração do background, nos dois canais, e compare os resultados utilizando a representação gráﬁca conArtiente. 

```{r}
par(mfrow=c(1,2))
c.spot <- bg.correct(chip1.spot)

# Raw data
ma.plot(c.spot)
title(main = "Raw")

# Background corrected
ma.plot(c.spot)
title(main="Corrected")
```


## c) Normalize o array e volte a comparar os resultados. 

```{r}
# grid normalization 
grid.n.spot <- grid.norm(c.spot, nr=2994, nc=5) # ??nr ??nc
#ri.plot(n.spot)
#ma.plot(n.spot)

# global normalization
global.n.spot <- global.norm(c.spot)
# ri.plot(n.spot)
# ma.plot(n.spot)

# comparing Raw vs Corrected vs Normalized & Corrected
par(mfrow=c(1,3))
ma.plot(chip1.spot)
ma.plot(c.spot)
ma.plot(global.n.spot)
par(mfrow=c(1,1))
```


## d) Calcule o Z-score para cada gene. Construa o gráﬁco adequado e baseie-se nele para estabelecer um ponto de corte que lhe permita criar listas de genes com expressão diferencial em Art e em Art.

```{r}
# Identifying differentially expressed genes
# Z-score, M-A plot
zScore1 <- Zscore(global.n.spot, type = "ma")

# plotting datasets - s.spot
Zscore.plot(zScore1)
abline(h=2, col='white', lty=2) 
abline(h=-2, col='white', lty=2)
```

# Chips 2 e 3
```{r}
# importing chips 2 and 3
chip2 <- read.table("chip2.txt", header = T)
chip3 <- read.table("chip3.txt", header = T)

# getting spot objects from chip data
spot2 <- read.spot("chip2.txt", header=T, cy3=2, bg.cy3=4, cy5=3, bg.cy5=5, ids=1, sep = "\t", is.ifc = FALSE)
#str(spot2)
spot3 <- read.spot("chip3.txt", header=T, cy3=2, bg.cy3=4, cy5=3, bg.cy5=5, ids=1, sep = "\t", is.ifc = FALSE)
#str(spot3)

# Background correction
spot2 <- bg.correct(spot2)
spot3 <- bg.correct(spot3)
```

## e) Normalize os dois arrays tendo em conta o processo de normalização considerado anteriormente.
```{r}
# grid normalization
grNorm2 <- grid.norm(mySpot = spot2, nr=2994, nc=5)
#ma.plot(grNorm2)

grNorm3 <- grid.norm(mySpot = spot3, nr=2994, nc=5)
#ma.plot(grNorm3)

# global normalization
glNorm2 <- global.norm(mySpot = spot2)
ma.plot(glNorm2)

glNorm3 <- global.norm(mySpot = spot3)
ma.plot(glNorm3)
```

## f) Proceda à normalização entre arrays fazendo uma transformação conveniente dos dados (sugestão: centering).

```{r}
# Chip1
M1 <- attr(global.n.spot, "spotData")
zratio1 <- log(M1$Cy5 / M1$Cy3, 2)
zmean1 <- mean(zratio1)
zstd1 <- sqrt(var(zratio1))
zChip1 <- (zratio1 - zmean1) / zstd1

# Chip2
M2 <- attr(glNorm2, "spotData")
zratio2 <- log(M2$Cy5, 2) - log(M2$Cy3, 2) 
zmean2 <- mean(zratio2)
zstd2 <- sqrt(var(zratio2))
zChip2 <- (zratio2 - zmean2) / zstd2

# Chip3
M3 <- attr(glNorm3, "spotData")
zratio3 <- log(M3$Cy5, 2) - log(M3$Cy3, 2) 
zmean3 <- mean(zratio3)
zstd3 <- sqrt(var(zratio3))
zChip3 <- (zratio3 - zmean3) / zstd3

zTable <- data.frame(zChip1, zChip2, zChip3)
boxplot(zTable, ylab="Z-score")

```


## g) Com base nos Z-scores identifique os genes com expressão diferencial nos três arrays. Comente este procedimento.

```{r}
allZscores <- rowMeans(zTable)

plot(allZscores, ylab = "Z-Score", xlab = "ID", ylim = c(-3,3))
abline(h = 2)
abline(h = -2)

tableZ <- data.frame(allZscores)
tableZ$ID <- as.character(M1$Id)
tableZ <- tableZ[, c(2,1)]

diffGenes <- tableZ$ID[abs(tableZ$allZscores) > 2]
diffGenes <- str_remove(diffGenes, "Id")
length(diffGenes) #26 Genes

length(diffGenes) / length(allZscores) # 0.009 - valor teórico é 0.01
```

```{r}
zScore2 <- Zscore(glNorm2, type="ma")
zScore3 <- Zscore(glNorm3, type="ma")

str(zScore3)
Zscore.plot(zScore1)
abline(h=2, col='white', lty=2) 
abline(h=-2, col='white', lty=2) 

Zscore.plot(zScore2)
abline(h=2, col='white', lty=2) 
abline(h=-2, col='white', lty=2) 

Zscore.plot(zScore3)
abline(h=2, col='white', lty=2) 
abline(h=-2, col='white', lty=2)
```

## h) Aplique o método bayesiano de Lonnstedt e Speed (package limma). Estabeleça algumas linhas de comando para identificar os genes com expressão diferencial e justifique o ponto de corte considerado.

Ponto de corte - Bi>0; explicação no vídeo da aula de 21/5 (1:55:00)
Selecionam-se genes com maior valor de B

```{r}
# Construção de tabela com logratios normalizados e os seus inversos
logMat <- data.frame(zratio1, zratio2, zratio3, -zratio1, -zratio2, -zratio3)

# Vetor design com valores dos coeficientes dos log-ratios
design2 <- c(1,1,1,-1,-1,-1)

# Aplicando modelo bayesiano de Lonnstedt e Speed aos rácios, segundo vetor design
fit2 <- lmFit(logMat, design2)
fit2 <- eBayes(fit2)

volcanoplot(fit2, highlight=20, style="B-statistic")
abline(h = 1.3)
abline(v = c(-1,1))

# Construção da tabela para os genes top-ranked do modelo anterior
table3 <- topTable(fit2, number=nrow(fit2), sort.by = "B")

# Seleção dos genes diferencialmente expressos
table4 <- subset(table3, abs(table3$logFC) > 1 & table3$B > 1.3)

# Identificação e contagem de genes diferencialmente expressos
diffBayes <- rownames(table4)
nrow(table4) # 9 genes
```

## i) Comente os resultados obtidos pelos dois métodos.

+ genArise: 26 genes
+ Lonnstedt & Speed: 9 genes

```{r}
diffBayes %in% diffGenes # 1, 4, 8, 9 estão presentes em ambos os vetores

finalDiff <- diffBayes[c(1,4,8,9)]
finalDiff

# apenas 4 genes identificados pelo método Bayesiano fazem também parte dos identificados pelo genArise
```

